 %(query-replace-regexp "\\\\sqsubseteq^{sh}_{\\([^}]*\\)}" "\\\\shiftpre[\\1]")
% --- LNCS ---'
\documentclass{llncs}

\usepackage{hyperref}
\usepackage[textsize=tiny]{todonotes}
\usepackage{etex}

\usepackage[all]{xy}
\SelectTips{cm}{}
% derivations and labels
\usepackage{proof}
\newcommand{\lab}[1]{\ensuremath{\mathsf{{#1}}}}
\newcommand{\slab}[1]{\ensuremath{\scriptstyle{\mathsf{{#1}}}}}

% ``boxed'' \infer command
\newcommand{\binfer}[3][]{
  \mbox{\infer[#1]{#2}{#3}}}

% Command for labels on the left side of the rule
%       \inferL{<name>}{<post>}{<pre>}
% generates:
%             <pre>
%      <name> ------
%             <post>
%
\newlength{\myheight}
\newcommand{\inferL}[3]
  {\settoheight{\myheight}{\mbox{${#2}$}}
   \raisebox{\myheight}{{#1}}
   \makebox[1mm]{}
   \mbox{\infer{#2}{#3}}
}

\usepackage{amssymb,graphicx,epsfig,color}
%\usepackage[scriptsize]{subfigure}
\usepackage{subcaption}
\usepackage{wrapfig}

% re-stating 
%\usepackage{thm-restate}

% showing labels
%\usepackage[inline]{showlabels}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{arrows,shapes,snakes,automata,backgrounds,petri,fit,positioning}
\tikzstyle{node}=[circle, draw=black, minimum size=1mm]
\tikzstyle{trans}=[font=\scriptsize]
\tikzstyle{lab}=[font=\small]


\newcommand{\pgfBox}{
  \begin{pgfonlayer}{background} 
    \fill[blue!2,thick,draw=black!50,rounded corners,inner sep=3mm] ([xshift=-1.5pt,yshift=-1.5pt]current bounding box.south west) rectangle ([xshift=1.5pt,yshift=1.5pt]current bounding box.north east);
  \end{pgfonlayer}
}



\newcommand{\Rrel}[1]   {\stackrel{{#1}}{\Longrightarrow}}
\newcommand{\oa}{\overline a}
\newcommand{\ob}{\overline b}
\newcommand{\oc}{\overline c}
\newcommand{\od}{\overline d}
\newcommand{\nil}{{\tt 0}}
\newcommand{\rec}{\emph{rec}}
\newcommand{\fn}[1]{{\mathtt{fn}}(#1)}
%\usepackage{latexsym}
\usepackage{stmaryrd}
\def\encodep#1{\llfloor#1\rrfloor}

\newcommand{\cat}[1]{\ensuremath{\mathbf{#1}}}

\newcommand{\dpo}{\textsc{dpo}}

% base classes of categories for adhesive and quasi adhesive case
\newcommand{\bAdh}{\ensuremath{\mathbb{B}}}
\newcommand{\bQAdh}{\ensuremath{\mathbb{QB}}}

%from pawel
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
%2 righe tolte da Fabio
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{cite}
\usepackage{float}
\usepackage{fancybox}


%%%%%%%% MATHEMATICAL NOTATION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%symbol for natural numbers
\newcommand{\nat}{\ensuremath{\mathbb{N}}}

% finite subset
\newcommand{\sfin}{\ensuremath{\subseteq_{\mathit{fin}}}}

% flattening of a multiset
\newcommand{\flt}[1]{\ensuremath{[\![{#1}]\!]}}

% compact elements
\newcommand{\compact}[1]{\ensuremath{\mathop{\mathsf{K}({#1})}}}

% principal ideal
\newcommand{\principal}[1]{\ensuremath{\mathop{\downarrow\!{#1}}}}

% ideal completion
\newcommand{\ideal}[1]{\ensuremath{\mathsf{Idl}({#1})}}

% complete prime elements
\newcommand{\pr}[1]{\ensuremath{\mathop{\mathit{pr}({#1})}}}
\newcommand{\wpr}[1]{\ensuremath{\mathop{\mathit{wpr}({#1})}}}

% irreducible elements
\newcommand{\ir}[1]{\ensuremath{\mathop{\mathit{ir}({#1})}}}

% difference of irreducible elements
\newcommand{\diff}[2]{\ensuremath{\delta({#1},{#2})}}

% immediate precedence

% abbreviation for event structure
% \newcommand{\esabbr}{event structure}
\newcommand{\esabbr}{\textsc{es}}
\newcommand{\esnabbr}{\textsc{esnb}}
\newcommand{\esnmabbr}{\textsc{esn}}
\newcommand{\eseqabbr}{\textsc{epes}}

% predecessor of an irreducible
\newcommand{\pred}[1]{\ensuremath{\mathit{p}({#1})}}

% irreducible elements in es domains
\newcommand{\esir}[2]{\ensuremath{\langle{#1}, {#2}\rangle}}

% equivalence classes [of irreducibles]
\newcommand{\eqclass}[2][]{\ensuremath{[{#2}]_{\scriptscriptstyle {#1}}}}
% union of the equivalence classes of the elements in a set
\newcommand{\eqclasscup}[2]{\ensuremath{{#2}_{\scriptscriptstyle {#1}}}}

\newcommand{\eqclassir}[1]{\ensuremath{\eqclass[\leftrightarrow^*]{#1}}}



% quotient of set wrt a relation
\newcommand{\quotient}[2]{\ensuremath{{#1}_{\scriptscriptstyle {#2}}}}


% category of event structures 
\newcommand{\es}{\ensuremath{\mathsf{ES}}}
% category of stable event structures 
\newcommand{\ses}{\ensuremath{\mathsf{sES}}}
% category of prime event structures 
\newcommand{\pes}{\ensuremath{\mathsf{pES}}}
% category of prime event structures with equivalence
\newcommand{\epes}{\ensuremath{\mathsf{epES}}}

% category of connected event structures 
\newcommand{\ces}{\ensuremath{\mathsf{cES}}}


% category of weak prime algebraic domains domains 
\newcommand{\WDom}{\ensuremath{\mathsf{wDom}}}
% category of domains
\newcommand{\Dom}{\ensuremath{\mathsf{Dom}}}
% category of prime algebraic domains
\newcommand{\PDom}{\ensuremath{\mathsf{pDom}}}


%%%%% NON BINARY CONFLICT

% category of event structures 
\newcommand{\esn}{\ensuremath{\mathsf{ES_{nb}}}}
% category of stable event structures 
\newcommand{\sesn}{\ensuremath{\mathsf{sES_n}}}

% category of connected event structures 
\newcommand{\cesn}{\ensuremath{\mathsf{cES_{nb}}}}

% category of prime event structures 
\newcommand{\pesn}{\ensuremath{\mathsf{pES_n}}}

% category of fusion domains 
\newcommand{\WDomb}{\ensuremath{\mathsf{wDom_b}}}
% category of domains
\newcommand{\Domb}{\ensuremath{\mathsf{Dom_b}}}
% category of prime algebraic domains
\newcommand{\PDomb}{\ensuremath{\mathsf{pDom_b}}}

%%%%% END NON BINARY CONFLICT


% slice category
\newcommand{\slice}[2]{\ensuremath{({#1} \downarrow {#2})}}


% event structure for a domain
\newcommand{\zev}[0]{\ensuremath{\mathcal{E}}}
\newcommand{\ev}[1]{\ensuremath{\zev({#1})}}

% from general to connected event structures
\newcommand{\zconnes}[0]{\ensuremath{\mathcal{C}}}
\newcommand{\connes}[1]{\ensuremath{\zconnes({#1})}}
% and inclusion
\newcommand{\zinces}[0]{\ensuremath{\mathcal{I}}}
\newcommand{\inces}[1]{\ensuremath{\zinces({#1})}}


% stable version
\newcommand{\zsev}[0]{\ensuremath{\mathcal{E}_S}}
\newcommand{\sev}[1]{\ensuremath{\zsev({#1})}}

% with equivalence
\newcommand{\zeveq}[0]{\ensuremath{\mathcal{E}_{eq}}}
\newcommand{\eveq}[1]{\ensuremath{\zeveq({#1})}}

% es with equivalence to es and vice
\newcommand{\zfuse}[0]{\ensuremath{\mathcal{M}}}
\newcommand{\fuse}[1]{\ensuremath{\zfuse({#1})}}
\newcommand{\zunf}[0]{\ensuremath{\zunf}}
\newcommand{\unf}[1]{\ensuremath{\mathcal{U}({#1})}}



% Winskel/Droste version
\newcommand{\zevwd}[0]{\ensuremath{\mathcal{E}_{wd}}}
\newcommand{\evwd}[1]{\ensuremath{\zevwd({#1})}}




% configurations of an event structure
\newcommand{\conf}[1]{\ensuremath{\mathit{Conf}({#1})}}
% finite configurations
\newcommand{\conff}[1]{\ensuremath{\mathit{Conf_F}({#1})}}

% product of the sets of minimal enablinsg
\newcommand{\pmin}[1]{\ensuremath{U_{#1}}}

% connectectedness of minimal enablinsg
\newcommand{\conn}[1]{\ensuremath{\stackrel{#1}{\frown}}}


% domain for an event structure or graph grammar
\newcommand{\zdom}[0]{\ensuremath{\mathcal{D}}}
\newcommand{\dom}[1]{\ensuremath{\zdom({#1})}}


\newcommand{\zdomeq}[0]{\ensuremath{\mathcal{D}_{eq}}}
\newcommand{\domeq}[1]{\ensuremath{\zdomeq({#1})}}


% partial order for a graph grammar
\newcommand{\poset}[1]{\ensuremath{\mathcal{P}({#1})}}

% stable version
\newcommand{\pdom}[1]{\ensuremath{\mathcal{D}_S({#1})}}
\newcommand{\ppdom}[0]{\ensuremath{\mathcal{D}_S}}


% powerset
\newcommand{\Pow}[1]{\ensuremath{\mathbf{2}^{#1}}}

% powerset of finite subsets
\newcommand{\Powfin}[1]{\ensuremath{\mathbf{2}_\mathit{fin}^{#1}}}

% powerset of subsets of cardinality <= 1
\newcommand{\Powone}[1]{\ensuremath{\mathbf{2}_1^{#1}}}

% integer interval
\newcommand{\interval}[2][1]{\ensuremath{[{#1},{#2}]}}

% domain interval
\newcommand{\dint}[2]{\ensuremath{[{#1},{#2}]}}

% set of intervals
\newcommand{\IntSet}[1]{\ensuremath{\mathop{\mathit{Int}({#1})}}}

% intervals to irreducibles and vice
\newcommand{\inir}{\ensuremath{\mathop{\mathit{\zeta}}}}
\newcommand{\irin}{\ensuremath{\mathop{\mathit{\iota}}}}

% permutations
\newcommand{\perm}{\sigma}

% causes
\newcommand{\causes}[1]{\ensuremath{\lfloor {#1})}}

%%% GRAPH GRAMMARS


\newcommand{\Abs}[1]{\ensuremath{\mathsf{Abs}({#1})}}
\newcommand{\tr}[1]{\ensuremath{\mathsf{Tr}({#1})}}
% fusion safe traces
\newcommand{\trs}[1]{\ensuremath{\mathsf{Tr}_s({#1})}}
%\newcommand{\graph}{\ensuremath{\mathsf{Graph}}}
\newcommand{\tgraph}[1]{\ensuremath{\mathsf{Graph}_{#1}}}
\newcommand{\can}[1]{\ensuremath{\mathsf{C}({#1})}}
% source and target of a derivation
\newcommand{\source}[1]{\ensuremath{\mathsf{s}({#1})}}
\newcommand{\target}[1]{\ensuremath{\mathsf{t}({#1})}}
\newcommand{\col}[1]{\ensuremath{\mathsf{col}({#1})}}

% left decorated trace
\newcommand{\ltrace}[1]{\ensuremath{\langle {#1}\rangle_c}}

\newcommand{\bx}[1]{\phantom{\big(}#1{\phantom{\big)}}}
\newcommand{\bxx}[1]{\,#1\,}
\newcommand{\cycl}[1]{\ensuremath{\mbox{\textcircled{\scriptsize{$#1$}}}}}
\renewcommand{\iff}{\ensuremath{\Leftrightarrow}}



%%% NEW

\usepackage{xparse}

% inversions
\newcommand{\inv}[1]{\ensuremath{inv}({#1})}

% direct shift
\newcommand{\shiftdir}[1][]{\ensuremath{\mathrel{{\rightsquigarrow}^{\mathit{sh}}_{#1}}}}

% shift preorder
\newcommand{\shiftpre}[1][]{\ensuremath{\mathrel{{\sqsubseteq}^{\mathit{sh}}_{#1}}}}

% shift equivalence
\newcommand{\shifteq}[1][]{\ensuremath{\mathrel{{\equiv}^\mathit{sh}_{#1}}}}

% transp{source}[target]: if target not specified source+1
\NewDocumentCommand{\transp}{m o}{%
  \ensuremath{({#1},%
  \IfNoValueTF{#2}%
    {{#1}+1}%
    {#2}%
    )}
}

\NewDocumentCommand{\mycommand}{o}{%
  % <code>
  \IfNoValueTF{#1}
    {code when no optional argument is passed}
    {code when the optional argument #1 is present}%
  % <code>
}
% interchange
\newcommand{\IC}[1]{\ensuremath{\mathit{IC}({#1})}}


\title{Ideas}

\begin{document}
\maketitle



  
\subsection*{Shift equivalence for non-right linear}

Sequential independence is a key ingredient in the concurrency theory
of DPO graph transformation, since it states when consecutive
rewriting steps can be switched, thus identifying them as causally
unrelated. The associated theory of shift equivalence on rewriting
sequences is well-understood for linear rules, including its
connection with standard models for concurrent systems such as event
structures.
%
This is not so for rules that are only left-linear, i.e., such that
their right-hand side may merge graph items.


In particular, if one just take the definition with general
interchange pairs, undesidered things might happen. In particular one
can have shift-equivalent derivations where the permutation is the
identity but which are non isomorphic (e.g., in GraphShift, page 1-2
$\rho_1 \shifteq \rho_3$, but $\rho_1 \not\equiv^{a} \rho_3$).
  
We want a notion of shift-equivalence that ensures some properties
which are indispensable to allow to interpret derivations up-to shift
as equivalent concurrent computations which differ only for the fact
that independent steps have switched. When moving around steps, we
should not lose track of the identity of the steps: this is essential
to be able to have an event structure semantics with a clearly defined
notion of event.


Hence we assume to deal with a notion of shift-equivalence between
derivations of the kind $\rho \shifteq_\sigma \rho'$ where
$\rho, \rho'$ consist of $n$ rewriting steps,
$\sigma: \interval{n} \to \interval{n}$ is a permutation (the idea
being that $\rho$ is obtained from $\rho'$ permutating the steps
according to $\sigma$) with - at least - the following properties:


\begin{itemize}
\item \textbf{Property 0}. Shift-equivalence is an equivalence! In
  particular it is symmetric. I.e., if $\rho \shifteq_\sigma \rho'$
  then $\rho' \shifteq_{\sigma^{-1}} \rho$;

\item \textbf{Property 1}. Derivations which are shift-equivalent via the
  identity permutation are isomorphic: if $\rho \shifteq \rho'$ then
  $\rho \equiv^a \rho'$; 
  
\item \textbf{Property 2}. Shift equivalence between adjacent rewriting steps
  is a property of the steps, invariant for permutation according to
  shift, i.e., if two steps are independent in some derivation $\rho$
  and we can prove that $\rho$ is shift-equivalent to some $\rho'$
  where the same steps are again consecutive, but possibly in a
  different position, then the steps are again independent, and also
  the converse holds. Formally, if $\rho \shifteq_\sigma \rho'$ with
  $\rho, \rho'$ consist of $n$ rewriting steps and for some
  $i \in \interval{n-1}$, $\sigma(i)+1 = \sigma(i+1)$, the the steps
  $i, i+1$ in $\rho$ are shift-independent iff $\sigma(i)$ and
  $\sigma(i)+1$ are so in $\rho'$.
\end{itemize}




\textbf{Question.} Taking the standard shift with generic interchange
pair, in the case of non-linear rules a counterexample to Property 1
is the one mentioned above.  Do we have a counterexample to Property
2? Not clear to me.


The above discussion should lead to

\begin{enumerate}
\item The conditions proposed by Andrea for a good notion of shift (in
  the draft, GraphShift, Def. 3, cond (1)-(5), with the addition of
  Lemma 12).
  
  \textbf{Questions}: Can we reduce the set of axioms? Do we need
  something else relating abstraction equivalence (iso of derivations)
  and shift? Relation with symmetries?

  
  
\item For left-linear rules, the notion of shift equivalence should
  require: uniqueness of the interchange pair and symmetry. Show that
  this satisfies the above

\item Apparently, the satisfaction of the properties above has not
  been explicitly observed, not even for the case of linear rules. If
  so, it is worth to remark it.

\item Does the theory above apply to other cases. E.g., if one wants a
  proper notion of causality (avoiding or-causality) a possibility
  seems to be to restrict the applicability condition for rules, to
  prevent fusions to act on already merged items (see section V.D in
  UnstableFull). Incidentally, note that the satisfaction of the
  conditions on shift depends not only on the notion of shift, but
  also on the notion of rewriting.

  In this specific case we expect to have a prime event structure (but
  this has to do with the second part of the work).
  
  
\end{enumerate}


\subsection*{Event structures for non-right linear}


Ideally, one would like to be able to work with an abstract notion of
shift-equivalence and just using its properties as singled out in the
previous part to derive a weak prime domain or connected event structure
for it. This is probably difficult, but one might need to add some
further properties to be proved for the specific notion of shift at
hand.


For this part, relevant material is section V of UnstableFull. We use abstraction equivalence (iso of derivations) $\equiv^{a}$ (Def. 36), shift-equivalence $\shifteq_\sigma$ (Def. 38, tracking the permutation) and their join $\equiv^c_\sigma$.

For linear rules on graphs it is known that two derivations are
related by $\rho \equiv^c_\sigma \rho'$ iff $\sigma$ is a consistent
permutation (Def. 40, UnstableFull). Roughly the idea is to take the colimit
and consider the rewriting steps over the colimit to deduce
dependencies. This was used in many places in the proofs, but for
left-linear rules the proof does not go through (only the implication
``if $\rho \equiv^c_\sigma \rho'$ then $\sigma$ is a consistent
permutation'' (Lemma 17(1)) seems to hold as the original proof do not
to rely on linearity, this should be double-checked, but the converse
is false).

In general, the hope could be to get rid of using consistent
permutations and use instead more abstract properties of
shift-equivalence as discussed in the first part. However, I think
that using the valid implication (``if $\rho \equiv^c_\sigma \rho'$
then $\sigma$ is a consistent permutation'') can be quite useful to track the identity of rewriting steps, as they can be identified with the items consumed in the colimit.

The general idea for getting a domain is to show that considering derivations are arrows from the source to the target graph, then the slice from the initial graph $\slice{[G_s]}{\tr{\mathcal{G}}}$ should be a pre-order, whose ideal completion is a weak prime domain.

Relevant technical lemma in UnstableFull are:

\begin{itemize}

\item
  \textbf{Lemma 17}. Points (2) and (3) should be hopefully consequences of the general properties of shift in the previous part and they play a role in proving that $\slice{[G_s]}{\tr{\mathcal{G}}}$ is a pre-order (Prop. 14)

\item
  \textbf{Lemma 19}.
  (1) says that if $\psi; \psi_1 \equiv^c_\sigma \psi'; \psi_1'$ and the permutation $\sigma$ sends $n$ steps of $\psi_1$ to $\psi'$ then such steps are not in $\psi$ and they will need to be in every $\phi_2$ such that $\psi; \phi_2 \equiv^c_\sigma \psi'; \phi_2'$. In particular there is $\phi_2$ consisting of exactly $n$ steps which allows for commutation. This allows essentially to deduce existence of minimal upper bounds, all with the same length. 
  Then (2) shows that all minimal upper bounds are isomorphic, so that we have a sup.

  Again, the hope is to obtain this from the abstract properties of
  shift.
  
\item \textbf{Proposition 15} shows that $\ideal{\poset{\mathcal{G}}}$
  is a domain, i.e., algebraic finitary (see Def. 6), while
  \textbf{Theorem 6} prove that it is weak prime.

  Here I think that the proofs are draft modifications of the original ones, changed after discovering the property on consistent permutations to be wrong. But they are drafty, to be redone maybe keeping some ideas.


\subsection*{Event structures for non-right linear, but jointly mono matches}

This is the idea in Section V.D. As mentioned above, ideally, if the proof in the previous part were based just on abstract properties of shift, one could hope of proving that shift in this context has the right properties, deduce that the construction produces a weak prime domain.

Then, one could observe that in this specific context actually all weak primes are primes an thus deduce that this provides a prime algebraic domain/pes semantics of fusion.
  
\end{itemize}




\end{document}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
